{
  "address": "0x824d304b7C17FF1E03bEA9b0f752BA9A2aff3426",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_size",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_end",
          "type": "uint256"
        }
      ],
      "name": "InvalidCodeAtRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WriteError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RECT_TAG_END",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "RECT_TAG_START",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SVG_TAG_END",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SVG_TAG_START",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WH_FILL_TAG",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "Y_TAG",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes1",
          "name": "_byte",
          "type": "bytes1"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode1ByteTo2Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes1",
          "name": "_byte",
          "type": "bytes1"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode1ByteTo4Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes1",
          "name": "_byte",
          "type": "bytes1"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode1ByteTo8Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pixelIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "paletteIndex",
          "type": "uint8"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode1Pixel",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pixelIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes1",
          "name": "paletteIndex",
          "type": "bytes1"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode1Pixel",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes3",
          "name": "_bytes",
          "type": "bytes3"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode3BytesTo4Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes3",
          "name": "_bytes",
          "type": "bytes3"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode3BytesTo8Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes5",
          "name": "_bytes",
          "type": "bytes5"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode5BytesTo8Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "startIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes7",
          "name": "_bytes",
          "type": "bytes7"
        },
        {
          "internalType": "string[]",
          "name": "palette",
          "type": "string[]"
        },
        {
          "internalType": "uint256",
          "name": "imageWidth",
          "type": "uint256"
        }
      ],
      "name": "decode7BytesTo8Pixels",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "palette",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getFill",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pointer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getFill",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pointer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bitsPaletteSize",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pixelsCount",
          "type": "uint256"
        }
      ],
      "name": "getImageBytes",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pointer",
          "type": "address"
        }
      ],
      "name": "getPalette",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "palette",
          "type": "bytes"
        }
      ],
      "name": "getPalette",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x36140d848781319f031b3170e373084435f9204846c49020e24dc49b536258f8",
  "receipt": {
    "to": null,
    "from": "0x6966Bdb480e7f7A48A7f6B198eE8b9462A265401",
    "contractAddress": "0x824d304b7C17FF1E03bEA9b0f752BA9A2aff3426",
    "transactionIndex": 0,
    "gasUsed": "1795870",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3a3f2b2b6126a15538856200836de7c2ebb8dfe821860037a8fdd88358d0dcf8",
    "transactionHash": "0x36140d848781319f031b3170e373084435f9204846c49020e24dc49b536258f8",
    "logs": [],
    "blockNumber": 14127146,
    "cumulativeGasUsed": "1795870",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b1c474271cc12cc20407c1418b89cffa",
  "metadata": "{\"compiler\":{\"version\":\"0.8.12+commit.f00d7308\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"InvalidCodeAtRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WriteError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RECT_TAG_END\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECT_TAG_START\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SVG_TAG_END\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SVG_TAG_START\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WH_FILL_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Y_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"_byte\",\"type\":\"bytes1\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode1ByteTo2Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"_byte\",\"type\":\"bytes1\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode1ByteTo4Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"_byte\",\"type\":\"bytes1\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode1ByteTo8Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pixelIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode1Pixel\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pixelIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"paletteIndex\",\"type\":\"bytes1\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode1Pixel\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes3\",\"name\":\"_bytes\",\"type\":\"bytes3\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode3BytesTo4Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes3\",\"name\":\"_bytes\",\"type\":\"bytes3\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode3BytesTo8Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes5\",\"name\":\"_bytes\",\"type\":\"bytes5\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode5BytesTo8Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes7\",\"name\":\"_bytes\",\"type\":\"bytes7\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"imageWidth\",\"type\":\"uint256\"}],\"name\":\"decode7BytesTo8Pixels\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFill\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFill\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bitsPaletteSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pixelsCount\",\"type\":\"uint256\"}],\"name\":\"getImageBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"getPalette\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"name\":\"getPalette\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Clement Walter <clement0walter@gmail.com>\",\"kind\":\"dev\",\"methods\":{\"decode1ByteTo2Pixels(uint256,bytes1,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 4 bits per pixel. In this case, one byte is       actually 2 rects.\",\"params\":{\"_byte\":\"The single byte containing 2 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Two filled <rect> with appropriate parameters as a string.\"}},\"decode1ByteTo4Pixels(uint256,bytes1,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 2 bits per pixel. In this case, one byte is       actually 4 rects.\",\"params\":{\"_byte\":\"The single byte containing 4 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Four filled <rect> with appropriate parameters as a string.\"}},\"decode1ByteTo8Pixels(uint256,bytes1,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 1 bit per pixel. In this case, one byte is       actually eight rects.\",\"params\":{\"_byte\":\"The single byte containing 8 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Eight filled <rect> with appropriate parameters as a string.\"}},\"decode1Pixel(uint256,bytes1,string[],uint256)\":{\"details\":\"Decode one single pixel, i.e. retrieve the color at the given index and produce a <rect> with appropriate parameters.      This is used as a base function for writing rect and is also relevant for cases where the palette uses 8 bits.\",\"params\":{\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"paletteIndex\":\"The value of the pixel at the given index, i.e. the index of the color in the palette.\",\"pixelIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"A filled <rect> with appropriate parameters as a string.\"}},\"decode3BytesTo4Pixels(uint256,bytes3,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 4 * 6 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.\",\"params\":{\"_bytes\":\"The bytes5 containing 4 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Four filled <rect> with appropriate parameters as a string.\"}},\"decode3BytesTo8Pixels(uint256,bytes3,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 3 bits per pixel. In this case, one has       indeed 3 * 8 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.\",\"params\":{\"_bytes\":\"The bytes3 containing 8 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Eight filled <rect> with appropriate parameters as a string.\"}},\"decode5BytesTo8Pixels(uint256,bytes5,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 5 * 8 = 40 bits = 8 * 5 = 5 bytes as a minimal bytes array to decode.\",\"params\":{\"_bytes\":\"The bytes5 containing 8 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Eight filled <rect> with appropriate parameters as a string.\"}},\"decode7BytesTo8Pixels(uint256,bytes7,string[],uint256)\":{\"details\":\"This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 7 * 8 = 56 bits = 8 * 7 = 7 bytes as a minimal bytes array to decode.\",\"params\":{\"_bytes\":\"The bytes7 containing 8 palette indexes.\",\"imageWidth\":\"Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\",\"palette\":\"The array of decoded colors as hex strings.\",\"startIndex\":\"The index of the current pixel in the image flatten array.\"},\"returns\":{\"_0\":\"Eight filled <rect> with appropriate parameters as a string.\"}},\"getFill(address,uint256)\":{\"details\":\"Returns one single color reading directly from the storage.\",\"params\":{\"index\":\"The index of the color to retrieve\",\"pointer\":\"The pointer to the palette bytes array where each color is R, G, B at storage i, i+1, i+2.\"},\"returns\":{\"_0\":\"The hexstring representation of the color, e.g. \\\"a3120f\\\".\"}},\"getFill(bytes,uint256)\":{\"details\":\"Returns one single color from a pre-loaded whole palette as a bytes array.\",\"params\":{\"index\":\"The index of the color to retrieve\",\"palette\":\"A bytes array encoding several RGB colors. Length should be a multiple of 3.\"},\"returns\":{\"_0\":\"The hexstring representation of the color, e.g. \\\"a3120f\\\".\"}},\"getImageBytes(address,uint256,uint256,uint256)\":{\"details\":\"All images have a constant number of pixels and consequently a constant number of bytes.       The function reads the corresponding number of bytes at the given _pointer_ address (written with SSTORE2.write).       It is more efficient to concat all the bytes of all the images in one single bytes (<24k) to save on gas       This function eventually helps retrieve one image given its index from the bytes array.\",\"params\":{\"bitsPaletteSize\":\"The number of bits used to index the palette, e.g. 3 bits for 2^3 = 8 colors, 8 bits for 2^8 = 256 colors.\",\"index\":\"The index of the image to retrieve.\",\"pixelsCount\":\"The number of pixels of the image, e.g. 32x32 = 1024 pixels. This function hence reads pixelsCount * bitsPaletteSize / 8 bytes.\",\"pointer\":\"The pointer returned by the SSTORE2.write function (or storeBytes for instance).\"},\"returns\":{\"_0\":\"The bytes of the image.\"}},\"getPalette(address)\":{\"details\":\"Decode the whole palette once for all and returns an array of hexstrings.\",\"params\":{\"pointer\":\"The pointer to the palette bytes array where each color is at storage at i, i+1, i+2.\"},\"returns\":{\"_0\":\"An array of hexstring representation of the color, e.g. \\\"a3120f\\\".\"}}},\"title\":\"PaletteRenderer This library can be used to render a palette encoded image on-chain. Palette encoding means that each pixel does not store the color itself, but rather the index of the color in the palette. The returned images is an url safe encoded image uri.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/PaletteRenderer.sol\":\"PaletteRenderer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf\",\"stackAllocation\":true}},\"runs\":2000},\"remappings\":[]},\"sources\":{\"@0xsequence/sstore2/contracts/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n  error WriteError();\\n\\n  /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n  function write(bytes memory _data) internal returns (address pointer) {\\n    // Append 00 to _data so contract can't be called\\n    // Build init code\\n    bytes memory code = Bytecode.creationCodeFor(\\n      abi.encodePacked(\\n        hex'00',\\n        _data\\n      )\\n    );\\n\\n    // Deploy contract using create\\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\\n\\n    // Address MUST be non-zero\\n    if (pointer == address(0)) revert WriteError();\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n  }\\n}\\n\",\"keccak256\":\"0x79e6f5c7bb6b22d142ad0ec37e00930cdbef28ab405214f7c0f94cbd58255383\",\"license\":\"MIT\"},\"@0xsequence/sstore2/contracts/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary Bytecode {\\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n  /**\\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\\n    /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n    return abi.encodePacked(\\n      hex\\\"63\\\",\\n      uint32(_code.length),\\n      hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n      _code\\n    );\\n  }\\n\\n  /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n  function codeSize(address _addr) internal view returns (uint256 size) {\\n    assembly { size := extcodesize(_addr) }\\n  }\\n\\n  /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\\n    uint256 csize = codeSize(_addr);\\n    if (csize == 0) return bytes(\\\"\\\");\\n\\n    if (_start > csize) return bytes(\\\"\\\");\\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \\n\\n    unchecked {\\n      uint256 reqSize = _end - _start;\\n      uint256 maxSize = csize - _start;\\n\\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n      assembly {\\n        // allocate output byte array - this could also be done without assembly\\n        // by using o_code = new bytes(size)\\n        oCode := mload(0x40)\\n        // new \\\"memory end\\\" including padding\\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\\n        // store length in memory\\n        mstore(oCode, size)\\n        // actually retrieve the code, this needs assembly\\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x40ef4ee5697507566574eda36358a76b523b3dfe7cb65da1630004fe6c5a7a45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"contracts/lib/Integers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Integers Library updated from https://github.com/willitscale/solidity-util\\n *\\n * In summary this is a simple library of integer functions which allow a simple\\n * conversion to and from strings\\n *\\n * @author Clement Walter <clement0walter@gmail.com>\\n */\\nlibrary Integers {\\n    /**\\n     * To String\\n     *\\n     * Converts an unsigned integer to the string equivalent value, returned as bytes\\n     * Equivalent to javascript's toString(base)\\n     *\\n     * @param _number The unsigned integer to be converted to a string\\n     * @param _base The base to convert the number to\\n     * @param  _padding The target length of the string; result will be padded with 0 to reach this length while padding\\n     *         of 0 means no padding\\n     * @return bytes The resulting ASCII string value\\n     */\\n    function toString(\\n        uint256 _number,\\n        uint8 _base,\\n        uint8 _padding\\n    ) public pure returns (string memory) {\\n        uint256 count = 0;\\n        uint256 b = _number;\\n        while (b != 0) {\\n            count++;\\n            b /= _base;\\n        }\\n        if (_number == 0) {\\n            count++;\\n        }\\n        bytes memory res;\\n        if (_padding == 0) {\\n            res = new bytes(count);\\n        } else {\\n            res = new bytes(_padding);\\n        }\\n        for (uint256 i = 0; i < count; ++i) {\\n            b = _number % _base;\\n            if (b < 10) {\\n                res[res.length - i - 1] = bytes1(uint8(b + 48)); // 0-9\\n            } else {\\n                res[res.length - i - 1] = bytes1(uint8((b % 10) + 65)); // A-F\\n            }\\n            _number /= _base;\\n        }\\n\\n        for (uint256 i = count; i < _padding; ++i) {\\n            res[res.length - i - 1] = hex\\\"30\\\"; // 0\\n        }\\n\\n        return string(res);\\n    }\\n\\n    function toString(uint256 _number) public pure returns (string memory) {\\n        return toString(_number, 10, 0);\\n    }\\n\\n    function toString(uint256 _number, uint8 _base)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return toString(_number, _base, 0);\\n    }\\n\\n    /**\\n     * Load 16\\n     *\\n     * Converts two bytes to a 16 bit unsigned integer\\n     *\\n     * @param _leadingBytes the first byte of the unsigned integer in [256, 65536]\\n     * @param _endingBytes the second byte of the unsigned integer in [0, 255]\\n     * @return uint16 The resulting integer value\\n     */\\n    function load16(bytes1 _leadingBytes, bytes1 _endingBytes)\\n        public\\n        pure\\n        returns (uint16)\\n    {\\n        return\\n            (uint16(uint8(_leadingBytes)) << 8) + uint16(uint8(_endingBytes));\\n    }\\n\\n    /**\\n     * Load 12\\n     *\\n     * Converts three bytes into two uint12 integers\\n     *\\n     * @return (uint16, uint16) The two uint16 values up to 2^12 each\\n     */\\n    function load12x2(\\n        bytes1 first,\\n        bytes1 second,\\n        bytes1 third\\n    ) public pure returns (uint16, uint16) {\\n        return (\\n            (uint16(uint8(first)) << 4) + (uint16(uint8(second)) >> 4),\\n            (uint16(uint8(second & hex\\\"0f\\\")) << 8) + uint16(uint8(third))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0f5b1dfb605720cb17df14949849463b989e5f65969c595de9aa62fd28bf7b2d\",\"license\":\"MIT\"},\"contracts/lib/PaletteRenderer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"@0xsequence/sstore2/contracts/SSTORE2.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\nimport {Integers} from \\\"../lib/Integers.sol\\\";\\n\\n/**\\n * @title PaletteRenderer\\n *\\n * This library can be used to render a palette encoded image on-chain.\\n * Palette encoding means that each pixel does not store the color itself, but rather the index of the\\n * color in the palette.\\n *\\n * The returned images is an url safe encoded image uri.\\n *\\n * @author Clement Walter <clement0walter@gmail.com>\\n */\\nlibrary PaletteRenderer {\\n    using Strings for uint256;\\n    using Integers for uint8;\\n\\n    string public constant RECT_TAG_START = \\\"%3crect%20x=%27\\\";\\n    string public constant Y_TAG = \\\"%27%20y=%27\\\";\\n    string public constant WH_FILL_TAG =\\n        \\\"%27%20width=%271%27%20height=%271%27%20fill=%27%23\\\";\\n    string public constant RECT_TAG_END = \\\"%27/%3e\\\";\\n    string public constant SVG_TAG_START =\\n        \\\"%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20viewBox=%270%200%2036%2036%27%20width=%27360px%27%20height=%27360px%27%3e\\\";\\n    string public constant SVG_TAG_END = \\\"%3c/svg%3e\\\";\\n\\n    /* @dev This can be used to store both images bytes and palettes bytes. It uses the SSTORE2 lib and returns the\\n     *      pointer to the storage address to be used, for example, in getImageBytes and getFill.\\n     * @param bytes The bytes to store.\\n     * @return The pointer to the storage address.\\n     */\\n    function storeBytes(bytes calldata _bytes) external returns (address) {\\n        return SSTORE2.write(_bytes);\\n    }\\n\\n    /** @dev All images have a constant number of pixels and consequently a constant number of bytes.\\n     *       The function reads the corresponding number of bytes at the given _pointer_ address (written with SSTORE2.write).\\n     *       It is more efficient to concat all the bytes of all the images in one single bytes (<24k) to save on gas\\n     *       This function eventually helps retrieve one image given its index from the bytes array.\\n     * @param pointer The pointer returned by the SSTORE2.write function (or storeBytes for instance).\\n     * @param index The index of the image to retrieve.\\n     * @param bitsPaletteSize The number of bits used to index the palette, e.g. 3 bits for 2^3 = 8 colors, 8 bits for 2^8 = 256 colors.\\n     * @param pixelsCount The number of pixels of the image, e.g. 32x32 = 1024 pixels. This function hence reads pixelsCount * bitsPaletteSize / 8 bytes.\\n     * @return The bytes of the image.\\n     */\\n    function getImageBytes(\\n        address pointer,\\n        uint256 index,\\n        uint256 bitsPaletteSize,\\n        uint256 pixelsCount\\n    ) public view returns (bytes memory) {\\n        uint256 start = index > 0\\n            ? ((index - 1) * bitsPaletteSize * pixelsCount) / 8\\n            : 0;\\n        return\\n            SSTORE2.read(\\n                pointer,\\n                start,\\n                start + (bitsPaletteSize * pixelsCount) / 8\\n            );\\n    }\\n\\n    /** @dev Returns one single color reading directly from the storage.\\n     * @param pointer The pointer to the palette bytes array where each color is R, G, B at storage i, i+1, i+2.\\n     * @param index The index of the color to retrieve\\n     * @return The hexstring representation of the color, e.g. \\\"a3120f\\\".\\n     */\\n    function getFill(address pointer, uint256 index)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        bytes memory palette = SSTORE2.read(pointer, index, index + 3);\\n        return\\n            string.concat(\\n                uint8(palette[0]).toString(16, 2),\\n                uint8(palette[1]).toString(16, 2),\\n                uint8(palette[2]).toString(16, 2)\\n            );\\n    }\\n\\n    /** @dev Returns one single color from a pre-loaded whole palette as a bytes array.\\n     * @param palette A bytes array encoding several RGB colors. Length should be a multiple of 3.\\n     * @param index The index of the color to retrieve\\n     * @return The hexstring representation of the color, e.g. \\\"a3120f\\\".\\n     */\\n    function getFill(bytes memory palette, uint256 index)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string.concat(\\n                uint8(palette[3 * index]).toString(16, 2),\\n                uint8(palette[3 * index + 1]).toString(16, 2),\\n                uint8(palette[3 * index + 2]).toString(16, 2)\\n            );\\n    }\\n\\n    /** @dev Decode the whole palette once for all and returns an array of hexstrings.\\n     * @param pointer The pointer to the palette bytes array where each color is at storage at i, i+1, i+2.\\n     * @return An array of hexstring representation of the color, e.g. \\\"a3120f\\\".\\n     */\\n    function getPalette(address pointer) public view returns (string[] memory) {\\n        bytes memory palette = SSTORE2.read(pointer);\\n        return getPalette(palette);\\n    }\\n\\n    function getPalette(bytes memory palette)\\n        public\\n        pure\\n        returns (string[] memory)\\n    {\\n        uint256 paletteSize = palette.length / 3;\\n        string[] memory paletteHex = new string[](paletteSize);\\n        for (uint256 i = 0; i < paletteSize; i++) {\\n            paletteHex[i] = getFill(palette, i);\\n        }\\n        return paletteHex;\\n    }\\n\\n    /**\\n     * @dev Decode one single pixel, i.e. retrieve the color at the given index and produce a <rect> with appropriate parameters.\\n     *      This is used as a base function for writing rect and is also relevant for cases where the palette uses 8 bits.\\n     * @param pixelIndex The index of the current pixel in the image flatten array.\\n     * @param paletteIndex The value of the pixel at the given index, i.e. the index of the color in the palette.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @return A filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode1Pixel(\\n        uint256 pixelIndex,\\n        bytes1 paletteIndex,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                RECT_TAG_START,\\n                (pixelIndex % imageWidth).toString(),\\n                Y_TAG,\\n                (pixelIndex / imageWidth).toString(),\\n                WH_FILL_TAG,\\n                palette[uint8(paletteIndex)],\\n                RECT_TAG_END\\n            );\\n    }\\n\\n    function decode1Pixel(\\n        uint256 pixelIndex,\\n        uint8 paletteIndex,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                RECT_TAG_START,\\n                (pixelIndex % imageWidth).toString(),\\n                Y_TAG,\\n                (pixelIndex / imageWidth).toString(),\\n                WH_FILL_TAG,\\n                palette[paletteIndex],\\n                RECT_TAG_END\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 1 bit per pixel. In this case, one byte is\\n     *       actually eight rects.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _byte The single byte containing 8 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Eight filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode1ByteTo8Pixels(\\n        uint256 startIndex,\\n        bytes1 _byte,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(startIndex, _byte >> 7, palette, imageWidth),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    (_byte >> 6) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    (_byte >> 5) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 3,\\n                    (_byte >> 4) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 4,\\n                    (_byte >> 3) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 5,\\n                    (_byte >> 2) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 6,\\n                    (_byte >> 1) & 0x01,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 7,\\n                    (_byte >> 0) & 0x01,\\n                    palette,\\n                    imageWidth\\n                )\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 2 bits per pixel. In this case, one byte is\\n     *       actually 4 rects.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _byte The single byte containing 4 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Four filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode1ByteTo4Pixels(\\n        uint256 startIndex,\\n        bytes1 _byte,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(startIndex, _byte >> 6, palette, imageWidth),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    (_byte >> 4) & 0x03,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    (_byte >> 2) & 0x03,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(startIndex + 3, _byte & 0x03, palette, imageWidth)\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 3 bits per pixel. In this case, one has\\n     *       indeed 3 * 8 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _bytes The bytes3 containing 8 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Eight filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode3BytesTo8Pixels(\\n        uint256 startIndex,\\n        bytes3 _bytes,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(\\n                    startIndex,\\n                    uint8(uint24(_bytes >> 21)),\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    uint8(uint24(_bytes >> 18)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    uint8(uint24(_bytes >> 15)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 3,\\n                    uint8(uint24(_bytes >> 12)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 4,\\n                    uint8(uint24(_bytes >> 9)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 5,\\n                    uint8(uint24(_bytes >> 6)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 6,\\n                    uint8(uint24(_bytes >> 3)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 7,\\n                    uint8(uint24(_bytes >> 0)) & 0x07,\\n                    palette,\\n                    imageWidth\\n                )\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 4 bits per pixel. In this case, one byte is\\n     *       actually 2 rects.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _byte The single byte containing 2 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Two filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode1ByteTo2Pixels(\\n        uint256 startIndex,\\n        bytes1 _byte,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(startIndex, _byte >> 4, palette, imageWidth),\\n                decode1Pixel(startIndex + 1, _byte & 0x0f, palette, imageWidth)\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has\\n     *       indeed 5 * 8 = 40 bits = 8 * 5 = 5 bytes as a minimal bytes array to decode.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _bytes The bytes5 containing 8 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Eight filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode5BytesTo8Pixels(\\n        uint256 startIndex,\\n        bytes5 _bytes,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(\\n                    startIndex,\\n                    uint8(uint40(_bytes >> 35)),\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    uint8(uint40(_bytes >> 30)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    uint8(uint40(_bytes >> 25)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 3,\\n                    uint8(uint40(_bytes >> 20)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 4,\\n                    uint8(uint40(_bytes >> 15)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 5,\\n                    uint8(uint40(_bytes >> 10)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 6,\\n                    uint8(uint40(_bytes >> 5)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 7,\\n                    uint8(uint40(_bytes >> 0)) & 0x1f,\\n                    palette,\\n                    imageWidth\\n                )\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has\\n     *       indeed 4 * 6 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _bytes The bytes5 containing 4 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Four filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode3BytesTo4Pixels(\\n        uint256 startIndex,\\n        bytes3 _bytes,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(\\n                    startIndex,\\n                    uint8(uint24(_bytes >> 18)),\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    uint8(uint24(_bytes >> 12)) & 0x3f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    uint8(uint24(_bytes >> 6)) & 0x3f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 3,\\n                    uint8(uint24(_bytes >> 0)) & 0x3f,\\n                    palette,\\n                    imageWidth\\n                )\\n            );\\n    }\\n\\n    /** @dev This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has\\n     *       indeed 7 * 8 = 56 bits = 8 * 7 = 7 bytes as a minimal bytes array to decode.\\n     * @param startIndex The index of the current pixel in the image flatten array.\\n     * @param _bytes The bytes7 containing 8 palette indexes.\\n     * @param palette The array of decoded colors as hex strings.\\n     * @param imageWidth Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.\\n     * @return Eight filled <rect> with appropriate parameters as a string.\\n     */\\n    function decode7BytesTo8Pixels(\\n        uint256 startIndex,\\n        bytes7 _bytes,\\n        string[] memory palette,\\n        uint256 imageWidth\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                decode1Pixel(\\n                    startIndex,\\n                    uint8(uint56(_bytes >> 49)),\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 1,\\n                    uint8(uint56(_bytes >> 42)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 2,\\n                    uint8(uint56(_bytes >> 35)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 3,\\n                    uint8(uint56(_bytes >> 28)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 4,\\n                    uint8(uint56(_bytes >> 21)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 5,\\n                    uint8(uint56(_bytes >> 14)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 6,\\n                    uint8(uint56(_bytes >> 7)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                ),\\n                decode1Pixel(\\n                    startIndex + 7,\\n                    uint8(uint56(_bytes >> 0)) & 0x7f,\\n                    palette,\\n                    imageWidth\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x2954a6f00a61310e6c08345a3653116fd6b440fd961eda43b49c3857a79ae3aa\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x611fa261003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101815760003560e01c8063657fb2e1116100e257806393cdbc7111610096578063ce5652a411610070578063ce5652a4146103a7578063d4488d48146103ba578063f9e06417146103cd57600080fd5b806393cdbc711461036e578063a87e8f7c14610381578063c030f08d1461039457600080fd5b80636f5c723b116100c75780636f5c723b1461030c578063890a161a1461034857806392caa7361461035b57600080fd5b8063657fb2e1146102b057806369db9ed0146102d057600080fd5b8063365c4c7911610139578063407134de1161011e578063407134de14610230578063480bc3c81461026c5780634d32bd7d1461027457600080fd5b8063365c4c791461020a5780633774c7981461021d57600080fd5b806314f8e1d41161016a57806314f8e1d4146101b7578063159c13ad146101ca5780631e6f1fb4146101f757600080fd5b8063030f53b4146101865780630a41f5da146101af575b600080fd5b6101996101943660046115d1565b6103e0565b6040516101a691906116b2565b60405180910390f35b610199610506565b6101996101c53660046116f6565b610522565b8180156101d657600080fd5b506101ea6101e536600461177e565b61059e565b6040516101a691906117f3565b610199610205366004611834565b6105e8565b61019961021836600461189d565b61069e565b61019961022b3660046118d3565b610792565b6101996040518060400160405280600781526020017f2532372f2533650000000000000000000000000000000000000000000000000081525081565b6101996109c2565b6101996040518060400160405280600b81526020017f253237253230793d25323700000000000000000000000000000000000000000081525081565b6102c36102be36600461193e565b6109de565b6040516101a691906119cf565b6101996040518060400160405280600f81526020017f25336372656374253230783d253237000000000000000000000000000000000081525081565b6101996040518060400160405280600a81526020017f2533632f7376672533650000000000000000000000000000000000000000000081525081565b6101996103563660046119e0565b6109fd565b610199610369366004611834565b610c16565b61019961037c3660046116f6565b610c93565b61019961038f366004611834565b610d70565b6102c36103a2366004611a02565b610e00565b6101996103b5366004611a70565b610eb2565b6101996103c8366004611834565b610f8f565b6101996103db366004611aa6565b61109f565b60408051808201909152600f81527f25336372656374253230783d253237000000000000000000000000000000000060208201526060906104296104248488611b03565b61110f565b60408051808201909152600b81527f253237253230793d253237000000000000000000000000000000000000000000602082015261046a610424868a611b2d565b604051806060016040528060328152602001611f3b60329139878960ff168151811061049857610498611b41565b60200260200101516040518060400160405280600781526020017f2532372f253365000000000000000000000000000000000000000000000000008152506040516020016104ec9796959493929190611b79565b60405160208183030381529060405290505b949350505050565b604051806060016040528060328152602001611f3b6032913981565b60606105348560fa86901c85856103e0565b610551610542876001611bd7565b603f60f488901c1686866103e0565b61056e61055f886002611bd7565b603f60ee89901c1687876103e0565b61058b61057c896003611bd7565b603f60e88a901c1688886103e0565b6040516020016104ec9493929190611bef565b60006105df83838080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061124192505050565b90505b92915050565b60408051808201909152600f81527f25336372656374253230783d2532370000000000000000000000000000000000602082015260609061062c6104248488611b03565b60408051808201909152600b81527f253237253230793d253237000000000000000000000000000000000000000000602082015261066d610424868a611b2d565b604051806060016040528060328152602001611f3b60329139878960f81c60ff168151811061049857610498611b41565b60606106b08560fb86901c85856103e0565b6106cd6106be876001611bd7565b601f60f688901c1686866103e0565b6106ea6106db886002611bd7565b601f60f189901c1687876103e0565b6107076106f8896003611bd7565b601f60ec8a901c1688886103e0565b6107246107158a6004611bd7565b601f60e78b901c1689896103e0565b6107416107328b6005611bd7565b601f60e28c901c168a8a6103e0565b61075e61074f8c6006611bd7565b601f60dd8d901c168b8b6103e0565b61077b61076c8d6007611bd7565b601f60d88e901c168c8c6103e0565b6040516020016104ec989796959493929190611c26565b6060826107a0836003611c91565b815181106107b0576107b0611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a69916107f49160f81c90601090600290600401611cca565b600060405180830381865af4158015610811573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108399190810190611d4a565b83610845846003611c91565b610850906001611bd7565b8151811061086057610860611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a69916108a49160f81c90601090600290600401611cca565b600060405180830381865af41580156108c1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108e99190810190611d4a565b846108f5856003611c91565b610900906002611bd7565b8151811061091057610910611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a69916109549160f81c90601090600290600401611cca565b600060405180830381865af4158015610971573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109999190810190611d4a565b6040516020016109ab93929190611d85565b604051602081830303815290604052905092915050565b6040518060a00160405280607b8152602001611ec0607b913981565b606060006109eb836112cc565b90506109f681610e00565b9392505050565b60606000610a168484610a11816003611bd7565b6112dc565b905080600081518110610a2b57610a2b611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a6991610a6f9160f81c90601090600290600401611cca565b600060405180830381865af4158015610a8c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ab49190810190611d4a565b81600181518110610ac757610ac7611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a6991610b0b9160f81c90601090600290600401611cca565b600060405180830381865af4158015610b28573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b509190810190611d4a565b82600281518110610b6357610b63611b41565b016020015160405163c1338a6960e01b815273e5d03576716d2D66Becf01a3F3BC7B80eb05952E9163c1338a6991610ba79160f81c90601090600290600401611cca565b600060405180830381865af4158015610bc4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610bec9190810190611d4a565b604051602001610bfe93929190611d85565b60405160208183030381529060405291505092915050565b6060610c4a857f0ff0000000000000000000000000000000000000000000000000000000000000600487901c1685856105e8565b610c82610c58876001611bd7565b7f0f00000000000000000000000000000000000000000000000000000000000000871686866105e8565b6040516020016104ec929190611da7565b6060610ca58560fd86901c85856103e0565b610cc2610cb3876001611bd7565b600760fa88901c1686866103e0565b610cdf610cd0886002611bd7565b600760f789901c1687876103e0565b610cfc610ced896003611bd7565b600760f48a901c1688886103e0565b610d19610d0a8a6004611bd7565b600760f18b901c1689896103e0565b610d36610d278b6005611bd7565b600760ee8c901c168a8a6103e0565b610d53610d448c6006611bd7565b600760eb8d901c168b8b6103e0565b61077b610d618d6007611bd7565b600760e88e901c168c8c6103e0565b6060610da4857f03fc000000000000000000000000000000000000000000000000000000000000600687901c1685856105e8565b610dc4610db2876001611bd7565b600360f81b600488901c1686866105e8565b610de4610dd2886002611bd7565b600360f81b600289901c1687876105e8565b61058b610df2896003611bd7565b600360f81b891688886105e8565b6060600060038351610e129190611b2d565b905060008167ffffffffffffffff811115610e2f57610e2f611420565b604051908082528060200260200182016040528015610e6257816020015b6060815260200190600190039081610e4d5790505b50905060005b82811015610eaa57610e7a8582610792565b828281518110610e8c57610e8c611b41565b60200260200101819052508080610ea290611dbd565b915050610e68565b509392505050565b6060610ec48560f986901c85856103e0565b610ee1610ed2876001611bd7565b607f60f288901c1686866103e0565b610efe610eef886002611bd7565b607f60eb89901c1687876103e0565b610f1b610f0c896003611bd7565b607f60e48a901c1688886103e0565b610f38610f298a6004611bd7565b607f60dd8b901c1689896103e0565b610f55610f468b6005611bd7565b607f60d68c901c168a8a6103e0565b610f72610f638c6006611bd7565b607f60cf8d901c168b8b6103e0565b61077b610f808d6007611bd7565b607f60c88e901c168c8c6103e0565b6060610fc3857f01fe000000000000000000000000000000000000000000000000000000000000600787901c1685856105e8565b610fe3610fd1876001611bd7565b600160f81b600688901c1686866105e8565b611003610ff1886002611bd7565b600160f81b600589901c1687876105e8565b611023611011896003611bd7565b600160f81b60048a901c1688886105e8565b6110436110318a6004611bd7565b600160f81b60038b901c1689896105e8565b6110636110518b6005611bd7565b600160f81b60028c901c168a8a6105e8565b6110836110718c6006611bd7565b600160f81b60018d901c168b8b6105e8565b61077b6110918d6007611bd7565b600160f81b8d168c8c6105e8565b606060008085116110b15760006110de565b600883856110c0600189611dd8565b6110ca9190611c91565b6110d49190611c91565b6110de9190611b2d565b9050611105868260086110f18789611c91565b6110fb9190611b2d565b610a119085611bd7565b9695505050505050565b60608161114f57505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b8160005b8115611179578061116381611dbd565b91506111729050600a83611b2d565b9150611153565b60008167ffffffffffffffff81111561119457611194611420565b6040519080825280601f01601f1916602001820160405280156111be576020820181803683370190505b5090505b84156104fe576111d3600183611dd8565b91506111e0600a86611b03565b6111eb906030611bd7565b60f81b81838151811061120057611200611b41565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535061123a600a86611b2d565b94506111c2565b60008061126c836040516020016112589190611dfa565b6040516020818303038152906040526112fd565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff82166112c6576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b60606105e2826001600019611329565b60606104fe846112ed856001611bd7565b6112f8856001611bd7565b611329565b6060815182604051602001611313929190611e52565b6040516020818303038152906040529050919050565b6060833b806113485750506040805160208101909152600081526109f6565b808411156113665750506040805160208101909152600081526109f6565b838310156113af578084846040517f2c4a89fa0000000000000000000000000000000000000000000000000000000081526004016113a693929190611e97565b60405180910390fd5b83830384820360008282106113c457826113c6565b815b60408051603f8301601f19168101909152818152955090508087602087018a3c505050509392505050565b805b81146113fe57600080fd5b50565b80356105e2816113f1565b60ff81166113f3565b80356105e28161140c565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff8211171561145c5761145c611420565b6040525050565b600061146e60405190565b905061147a8282611436565b919050565b600067ffffffffffffffff82111561149957611499611420565b5060209081020190565b600067ffffffffffffffff8211156114bd576114bd611420565b601f19601f83011660200192915050565b82818337506000910152565b60006114ed6114e8846114a3565b611463565b90508281526020810184848401111561150857611508600080fd5b610eaa8482856114ce565b600082601f83011261152757611527600080fd5b81356104fe8482602086016114da565b60006115456114e88461147f565b8381529050602080820190840283018581111561156457611564600080fd5b835b818110156115a357803567ffffffffffffffff81111561158857611588600080fd5b85016115948882611513565b84525060209283019201611566565b5050509392505050565b600082601f8301126115c1576115c1600080fd5b81356104fe848260208601611537565b600080600080608085870312156115ea576115ea600080fd5b60006115f68787611401565b945050602061160787828801611415565b935050604085013567ffffffffffffffff81111561162757611627600080fd5b611633878288016115ad565b925050606061164487828801611401565b91505092959194509250565b60005b8381101561166b578181015183820152602001611653565b8381111561167a576000848401525b50505050565b600061168a825190565b8084526020840193506116a1818560208601611650565b601f01601f19169290920192915050565b602080825281016105df8184611680565b7fffffff000000000000000000000000000000000000000000000000000000000081166113f3565b80356105e2816116c3565b6000806000806080858703121561170f5761170f600080fd5b600061171b8787611401565b9450506020611607878288016116eb565b60008083601f84011261174157611741600080fd5b50813567ffffffffffffffff81111561175c5761175c600080fd5b60208301915083600182028301111561177757611777600080fd5b9250929050565b6000806020838503121561179457611794600080fd5b823567ffffffffffffffff8111156117ae576117ae600080fd5b6117ba8582860161172c565b92509250509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82166105e2565b6117ed816117c6565b82525050565b602081016105e282846117e4565b7fff0000000000000000000000000000000000000000000000000000000000000081166113f3565b80356105e281611801565b6000806000806080858703121561184d5761184d600080fd5b60006118598787611401565b945050602061160787828801611829565b7fffffffffff00000000000000000000000000000000000000000000000000000081166113f3565b80356105e28161186a565b600080600080608085870312156118b6576118b6600080fd5b60006118c28787611401565b945050602061160787828801611892565b600080604083850312156118e9576118e9600080fd5b823567ffffffffffffffff81111561190357611903600080fd5b61190f85828601611513565b925050602061192085828601611401565b9150509250929050565b6113f3816117c6565b80356105e28161192a565b60006020828403121561195357611953600080fd5b60006104fe8484611933565b60006105df8383611680565b6000611975825190565b8084526020840193508360208202850161198f8560200190565b60005b848110156119c357838303885281516119ab848261195f565b93505060208201602098909801979150600101611992565b50909695505050505050565b602080825281016105df818461196b565b600080604083850312156119f6576119f6600080fd5b600061190f8585611933565b600060208284031215611a1757611a17600080fd5b813567ffffffffffffffff811115611a3157611a31600080fd5b6104fe84828501611513565b7fffffffffffffff0000000000000000000000000000000000000000000000000081166113f3565b80356105e281611a3d565b60008060008060808587031215611a8957611a89600080fd5b6000611a958787611401565b945050602061160787828801611a65565b60008060008060808587031215611abf57611abf600080fd5b6000611acb8787611933565b9450506020611adc87828801611401565b935050604061163387828801611401565b634e487b7160e01b600052601260045260246000fd5b600082611b1257611b12611aed565b500690565b634e487b7160e01b600052601160045260246000fd5b600082611b3c57611b3c611aed565b500490565b634e487b7160e01b600052603260045260246000fd5b6000611b61825190565b611b6f818560208601611650565b9290920192915050565b611b838189611b57565b9050611b8f8188611b57565b9050611b9b8187611b57565b9050611ba78186611b57565b9050611bb38185611b57565b9050611bbf8184611b57565b9050611bcb8183611b57565b98975050505050505050565b60008219821115611bea57611bea611b17565b500190565b611bf98186611b57565b9050611c058185611b57565b9050611c118184611b57565b9050611c1d8183611b57565b95945050505050565b611c30818a611b57565b9050611c3c8189611b57565b9050611c488188611b57565b9050611c548187611b57565b9050611c608186611b57565b9050611c6c8185611b57565b9050611c788184611b57565b9050611c848183611b57565b9998505050505050505050565b6000816000190483118215151615611cab57611cab611b17565b500290565b806117ed565b600060ff82166105e2565b6117ed81611cb6565b60608101611cd88286611cb0565b611ce56020830185611cc1565b6104fe6040830184611cc1565b6000611d006114e8846114a3565b905082815260208101848484011115611d1b57611d1b600080fd5b610eaa848285611650565b600082601f830112611d3a57611d3a600080fd5b81516104fe848260208601611cf2565b600060208284031215611d5f57611d5f600080fd5b815167ffffffffffffffff811115611d7957611d79600080fd5b6104fe84828501611d26565b611d8f8185611b57565b9050611d9b8184611b57565b90506104fe8183611b57565b611db18184611b57565b90506109f68183611b57565b6000600019821415611dd157611dd1611b17565b5060010190565b600082821015611dea57611dea611b17565b500390565b600081525b60010190565b611e0381611def565b90506105e28183611b57565b7f63000000000000000000000000000000000000000000000000000000000000008152611df4565b60006105e28260e01b90565b6117ed63ffffffff8216611e37565b611e5b81611e0f565b9050611e678184611e43565b600401611db1817f80600e6000396000f30000000000000000000000000000000000000000000000815260090190565b60608101611ea58286611cb0565b611eb26020830185611cb0565b6104fe6040830184611cb056fe253363737667253230786d6c6e733d253237687474703a2f2f7777772e77332e6f72672f323030302f73766725323725323076696577426f783d25323730253230302532303336253230333625323725323077696474683d25323733363070782532372532306865696768743d253237333630707825323725336525323725323077696474683d253237312532372532306865696768743d2532373125323725323066696c6c3d253237253233a2646970667358221220ef8192f26e39030753e08a8b633e4090460b6d8a3e819c599b8db4f47221fdb664736f6c634300080c0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101815760003560e01c8063657fb2e1116100e257806393cdbc7111610096578063ce5652a411610070578063ce5652a4146103a7578063d4488d48146103ba578063f9e06417146103cd57600080fd5b806393cdbc711461036e578063a87e8f7c14610381578063c030f08d1461039457600080fd5b80636f5c723b116100c75780636f5c723b1461030c578063890a161a1461034857806392caa7361461035b57600080fd5b8063657fb2e1146102b057806369db9ed0146102d057600080fd5b8063365c4c7911610139578063407134de1161011e578063407134de14610230578063480bc3c81461026c5780634d32bd7d1461027457600080fd5b8063365c4c791461020a5780633774c7981461021d57600080fd5b806314f8e1d41161016a57806314f8e1d4146101b7578063159c13ad146101ca5780631e6f1fb4146101f757600080fd5b8063030f53b4146101865780630a41f5da146101af575b600080fd5b6101996101943660046115d1565b6103e0565b6040516101a691906116b2565b60405180910390f35b610199610506565b6101996101c53660046116f6565b610522565b8180156101d657600080fd5b506101ea6101e536600461177e565b61059e565b6040516101a691906117f3565b610199610205366004611834565b6105e8565b61019961021836600461189d565b61069e565b61019961022b3660046118d3565b610792565b6101996040518060400160405280600781526020017f2532372f2533650000000000000000000000000000000000000000000000000081525081565b6101996109c2565b6101996040518060400160405280600b81526020017f253237253230793d25323700000000000000000000000000000000000000000081525081565b6102c36102be36600461193e565b6109de565b6040516101a691906119cf565b6101996040518060400160405280600f81526020017f25336372656374253230783d253237000000000000000000000000000000000081525081565b6101996040518060400160405280600a81526020017f2533632f7376672533650000000000000000000000000000000000000000000081525081565b6101996103563660046119e0565b6109fd565b610199610369366004611834565b610c16565b61019961037c3660046116f6565b610c93565b61019961038f366004611834565b610d70565b6102c36103a2366004611a02565b610e00565b6101996103b5366004611a70565b610eb2565b6101996103c8366004611834565b610f8f565b6101996103db366004611aa6565b61109f565b60408051808201909152600f81527f25336372656374253230783d253237000000000000000000000000000000000060208201526060906104296104248488611b03565b61110f565b60408051808201909152600b81527f253237253230793d253237000000000000000000000000000000000000000000602082015261046a610424868a611b2d565b604051806060016040528060328152602001611f3b60329139878960ff168151811061049857610498611b41565b60200260200101516040518060400160405280600781526020017f2532372f253365000000000000000000000000000000000000000000000000008152506040516020016104ec9796959493929190611b79565b60405160208183030381529060405290505b949350505050565b604051806060016040528060328152602001611f3b6032913981565b60606105348560fa86901c85856103e0565b610551610542876001611bd7565b603f60f488901c1686866103e0565b61056e61055f886002611bd7565b603f60ee89901c1687876103e0565b61058b61057c896003611bd7565b603f60e88a901c1688886103e0565b6040516020016104ec9493929190611bef565b60006105df83838080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061124192505050565b90505b92915050565b60408051808201909152600f81527f25336372656374253230783d2532370000000000000000000000000000000000602082015260609061062c6104248488611b03565b60408051808201909152600b81527f253237253230793d253237000000000000000000000000000000000000000000602082015261066d610424868a611b2d565b604051806060016040528060328152602001611f3b60329139878960f81c60ff168151811061049857610498611b41565b60606106b08560fb86901c85856103e0565b6106cd6106be876001611bd7565b601f60f688901c1686866103e0565b6106ea6106db886002611bd7565b601f60f189901c1687876103e0565b6107076106f8896003611bd7565b601f60ec8a901c1688886103e0565b6107246107158a6004611bd7565b601f60e78b901c1689896103e0565b6107416107328b6005611bd7565b601f60e28c901c168a8a6103e0565b61075e61074f8c6006611bd7565b601f60dd8d901c168b8b6103e0565b61077b61076c8d6007611bd7565b601f60d88e901c168c8c6103e0565b6040516020016104ec989796959493929190611c26565b6060826107a0836003611c91565b815181106107b0576107b0611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a69916107f49160f81c90601090600290600401611cca565b600060405180830381865af4158015610811573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108399190810190611d4a565b83610845846003611c91565b610850906001611bd7565b8151811061086057610860611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a69916108a49160f81c90601090600290600401611cca565b600060405180830381865af41580156108c1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108e99190810190611d4a565b846108f5856003611c91565b610900906002611bd7565b8151811061091057610910611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a69916109549160f81c90601090600290600401611cca565b600060405180830381865af4158015610971573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109999190810190611d4a565b6040516020016109ab93929190611d85565b604051602081830303815290604052905092915050565b6040518060a00160405280607b8152602001611ec0607b913981565b606060006109eb836112cc565b90506109f681610e00565b9392505050565b60606000610a168484610a11816003611bd7565b6112dc565b905080600081518110610a2b57610a2b611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a6991610a6f9160f81c90601090600290600401611cca565b600060405180830381865af4158015610a8c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ab49190810190611d4a565b81600181518110610ac757610ac7611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a6991610b0b9160f81c90601090600290600401611cca565b600060405180830381865af4158015610b28573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b509190810190611d4a565b82600281518110610b6357610b63611b41565b016020015160405163c1338a6960e01b815273__$6cc8f8b41053aebd660af83ec8df928129$__9163c1338a6991610ba79160f81c90601090600290600401611cca565b600060405180830381865af4158015610bc4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610bec9190810190611d4a565b604051602001610bfe93929190611d85565b60405160208183030381529060405291505092915050565b6060610c4a857f0ff0000000000000000000000000000000000000000000000000000000000000600487901c1685856105e8565b610c82610c58876001611bd7565b7f0f00000000000000000000000000000000000000000000000000000000000000871686866105e8565b6040516020016104ec929190611da7565b6060610ca58560fd86901c85856103e0565b610cc2610cb3876001611bd7565b600760fa88901c1686866103e0565b610cdf610cd0886002611bd7565b600760f789901c1687876103e0565b610cfc610ced896003611bd7565b600760f48a901c1688886103e0565b610d19610d0a8a6004611bd7565b600760f18b901c1689896103e0565b610d36610d278b6005611bd7565b600760ee8c901c168a8a6103e0565b610d53610d448c6006611bd7565b600760eb8d901c168b8b6103e0565b61077b610d618d6007611bd7565b600760e88e901c168c8c6103e0565b6060610da4857f03fc000000000000000000000000000000000000000000000000000000000000600687901c1685856105e8565b610dc4610db2876001611bd7565b600360f81b600488901c1686866105e8565b610de4610dd2886002611bd7565b600360f81b600289901c1687876105e8565b61058b610df2896003611bd7565b600360f81b891688886105e8565b6060600060038351610e129190611b2d565b905060008167ffffffffffffffff811115610e2f57610e2f611420565b604051908082528060200260200182016040528015610e6257816020015b6060815260200190600190039081610e4d5790505b50905060005b82811015610eaa57610e7a8582610792565b828281518110610e8c57610e8c611b41565b60200260200101819052508080610ea290611dbd565b915050610e68565b509392505050565b6060610ec48560f986901c85856103e0565b610ee1610ed2876001611bd7565b607f60f288901c1686866103e0565b610efe610eef886002611bd7565b607f60eb89901c1687876103e0565b610f1b610f0c896003611bd7565b607f60e48a901c1688886103e0565b610f38610f298a6004611bd7565b607f60dd8b901c1689896103e0565b610f55610f468b6005611bd7565b607f60d68c901c168a8a6103e0565b610f72610f638c6006611bd7565b607f60cf8d901c168b8b6103e0565b61077b610f808d6007611bd7565b607f60c88e901c168c8c6103e0565b6060610fc3857f01fe000000000000000000000000000000000000000000000000000000000000600787901c1685856105e8565b610fe3610fd1876001611bd7565b600160f81b600688901c1686866105e8565b611003610ff1886002611bd7565b600160f81b600589901c1687876105e8565b611023611011896003611bd7565b600160f81b60048a901c1688886105e8565b6110436110318a6004611bd7565b600160f81b60038b901c1689896105e8565b6110636110518b6005611bd7565b600160f81b60028c901c168a8a6105e8565b6110836110718c6006611bd7565b600160f81b60018d901c168b8b6105e8565b61077b6110918d6007611bd7565b600160f81b8d168c8c6105e8565b606060008085116110b15760006110de565b600883856110c0600189611dd8565b6110ca9190611c91565b6110d49190611c91565b6110de9190611b2d565b9050611105868260086110f18789611c91565b6110fb9190611b2d565b610a119085611bd7565b9695505050505050565b60608161114f57505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b8160005b8115611179578061116381611dbd565b91506111729050600a83611b2d565b9150611153565b60008167ffffffffffffffff81111561119457611194611420565b6040519080825280601f01601f1916602001820160405280156111be576020820181803683370190505b5090505b84156104fe576111d3600183611dd8565b91506111e0600a86611b03565b6111eb906030611bd7565b60f81b81838151811061120057611200611b41565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535061123a600a86611b2d565b94506111c2565b60008061126c836040516020016112589190611dfa565b6040516020818303038152906040526112fd565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff82166112c6576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b60606105e2826001600019611329565b60606104fe846112ed856001611bd7565b6112f8856001611bd7565b611329565b6060815182604051602001611313929190611e52565b6040516020818303038152906040529050919050565b6060833b806113485750506040805160208101909152600081526109f6565b808411156113665750506040805160208101909152600081526109f6565b838310156113af578084846040517f2c4a89fa0000000000000000000000000000000000000000000000000000000081526004016113a693929190611e97565b60405180910390fd5b83830384820360008282106113c457826113c6565b815b60408051603f8301601f19168101909152818152955090508087602087018a3c505050509392505050565b805b81146113fe57600080fd5b50565b80356105e2816113f1565b60ff81166113f3565b80356105e28161140c565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff8211171561145c5761145c611420565b6040525050565b600061146e60405190565b905061147a8282611436565b919050565b600067ffffffffffffffff82111561149957611499611420565b5060209081020190565b600067ffffffffffffffff8211156114bd576114bd611420565b601f19601f83011660200192915050565b82818337506000910152565b60006114ed6114e8846114a3565b611463565b90508281526020810184848401111561150857611508600080fd5b610eaa8482856114ce565b600082601f83011261152757611527600080fd5b81356104fe8482602086016114da565b60006115456114e88461147f565b8381529050602080820190840283018581111561156457611564600080fd5b835b818110156115a357803567ffffffffffffffff81111561158857611588600080fd5b85016115948882611513565b84525060209283019201611566565b5050509392505050565b600082601f8301126115c1576115c1600080fd5b81356104fe848260208601611537565b600080600080608085870312156115ea576115ea600080fd5b60006115f68787611401565b945050602061160787828801611415565b935050604085013567ffffffffffffffff81111561162757611627600080fd5b611633878288016115ad565b925050606061164487828801611401565b91505092959194509250565b60005b8381101561166b578181015183820152602001611653565b8381111561167a576000848401525b50505050565b600061168a825190565b8084526020840193506116a1818560208601611650565b601f01601f19169290920192915050565b602080825281016105df8184611680565b7fffffff000000000000000000000000000000000000000000000000000000000081166113f3565b80356105e2816116c3565b6000806000806080858703121561170f5761170f600080fd5b600061171b8787611401565b9450506020611607878288016116eb565b60008083601f84011261174157611741600080fd5b50813567ffffffffffffffff81111561175c5761175c600080fd5b60208301915083600182028301111561177757611777600080fd5b9250929050565b6000806020838503121561179457611794600080fd5b823567ffffffffffffffff8111156117ae576117ae600080fd5b6117ba8582860161172c565b92509250509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82166105e2565b6117ed816117c6565b82525050565b602081016105e282846117e4565b7fff0000000000000000000000000000000000000000000000000000000000000081166113f3565b80356105e281611801565b6000806000806080858703121561184d5761184d600080fd5b60006118598787611401565b945050602061160787828801611829565b7fffffffffff00000000000000000000000000000000000000000000000000000081166113f3565b80356105e28161186a565b600080600080608085870312156118b6576118b6600080fd5b60006118c28787611401565b945050602061160787828801611892565b600080604083850312156118e9576118e9600080fd5b823567ffffffffffffffff81111561190357611903600080fd5b61190f85828601611513565b925050602061192085828601611401565b9150509250929050565b6113f3816117c6565b80356105e28161192a565b60006020828403121561195357611953600080fd5b60006104fe8484611933565b60006105df8383611680565b6000611975825190565b8084526020840193508360208202850161198f8560200190565b60005b848110156119c357838303885281516119ab848261195f565b93505060208201602098909801979150600101611992565b50909695505050505050565b602080825281016105df818461196b565b600080604083850312156119f6576119f6600080fd5b600061190f8585611933565b600060208284031215611a1757611a17600080fd5b813567ffffffffffffffff811115611a3157611a31600080fd5b6104fe84828501611513565b7fffffffffffffff0000000000000000000000000000000000000000000000000081166113f3565b80356105e281611a3d565b60008060008060808587031215611a8957611a89600080fd5b6000611a958787611401565b945050602061160787828801611a65565b60008060008060808587031215611abf57611abf600080fd5b6000611acb8787611933565b9450506020611adc87828801611401565b935050604061163387828801611401565b634e487b7160e01b600052601260045260246000fd5b600082611b1257611b12611aed565b500690565b634e487b7160e01b600052601160045260246000fd5b600082611b3c57611b3c611aed565b500490565b634e487b7160e01b600052603260045260246000fd5b6000611b61825190565b611b6f818560208601611650565b9290920192915050565b611b838189611b57565b9050611b8f8188611b57565b9050611b9b8187611b57565b9050611ba78186611b57565b9050611bb38185611b57565b9050611bbf8184611b57565b9050611bcb8183611b57565b98975050505050505050565b60008219821115611bea57611bea611b17565b500190565b611bf98186611b57565b9050611c058185611b57565b9050611c118184611b57565b9050611c1d8183611b57565b95945050505050565b611c30818a611b57565b9050611c3c8189611b57565b9050611c488188611b57565b9050611c548187611b57565b9050611c608186611b57565b9050611c6c8185611b57565b9050611c788184611b57565b9050611c848183611b57565b9998505050505050505050565b6000816000190483118215151615611cab57611cab611b17565b500290565b806117ed565b600060ff82166105e2565b6117ed81611cb6565b60608101611cd88286611cb0565b611ce56020830185611cc1565b6104fe6040830184611cc1565b6000611d006114e8846114a3565b905082815260208101848484011115611d1b57611d1b600080fd5b610eaa848285611650565b600082601f830112611d3a57611d3a600080fd5b81516104fe848260208601611cf2565b600060208284031215611d5f57611d5f600080fd5b815167ffffffffffffffff811115611d7957611d79600080fd5b6104fe84828501611d26565b611d8f8185611b57565b9050611d9b8184611b57565b90506104fe8183611b57565b611db18184611b57565b90506109f68183611b57565b6000600019821415611dd157611dd1611b17565b5060010190565b600082821015611dea57611dea611b17565b500390565b600081525b60010190565b611e0381611def565b90506105e28183611b57565b7f63000000000000000000000000000000000000000000000000000000000000008152611df4565b60006105e28260e01b90565b6117ed63ffffffff8216611e37565b611e5b81611e0f565b9050611e678184611e43565b600401611db1817f80600e6000396000f30000000000000000000000000000000000000000000000815260090190565b60608101611ea58286611cb0565b611eb26020830185611cb0565b6104fe6040830184611cb056fe253363737667253230786d6c6e733d253237687474703a2f2f7777772e77332e6f72672f323030302f73766725323725323076696577426f783d25323730253230302532303336253230333625323725323077696474683d25323733363070782532372532306865696768743d253237333630707825323725336525323725323077696474683d253237312532372532306865696768743d2532373125323725323066696c6c3d253237253233a2646970667358221220ef8192f26e39030753e08a8b633e4090460b6d8a3e819c599b8db4f47221fdb664736f6c634300080c0033",
  "libraries": {
    "Integers": "0xe5d03576716d2D66Becf01a3F3BC7B80eb05952E"
  },
  "devdoc": {
    "author": "Clement Walter <clement0walter@gmail.com>",
    "kind": "dev",
    "methods": {
      "decode1ByteTo2Pixels(uint256,bytes1,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 4 bits per pixel. In this case, one byte is       actually 2 rects.",
        "params": {
          "_byte": "The single byte containing 2 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Two filled <rect> with appropriate parameters as a string."
        }
      },
      "decode1ByteTo4Pixels(uint256,bytes1,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 2 bits per pixel. In this case, one byte is       actually 4 rects.",
        "params": {
          "_byte": "The single byte containing 4 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Four filled <rect> with appropriate parameters as a string."
        }
      },
      "decode1ByteTo8Pixels(uint256,bytes1,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 1 bit per pixel. In this case, one byte is       actually eight rects.",
        "params": {
          "_byte": "The single byte containing 8 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Eight filled <rect> with appropriate parameters as a string."
        }
      },
      "decode1Pixel(uint256,bytes1,string[],uint256)": {
        "details": "Decode one single pixel, i.e. retrieve the color at the given index and produce a <rect> with appropriate parameters.      This is used as a base function for writing rect and is also relevant for cases where the palette uses 8 bits.",
        "params": {
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "paletteIndex": "The value of the pixel at the given index, i.e. the index of the color in the palette.",
          "pixelIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "A filled <rect> with appropriate parameters as a string."
        }
      },
      "decode3BytesTo4Pixels(uint256,bytes3,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 4 * 6 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.",
        "params": {
          "_bytes": "The bytes5 containing 4 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Four filled <rect> with appropriate parameters as a string."
        }
      },
      "decode3BytesTo8Pixels(uint256,bytes3,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 3 bits per pixel. In this case, one has       indeed 3 * 8 = 24 bits = 8 * 3 = 3 bytes as a minimal bytes array to decode.",
        "params": {
          "_bytes": "The bytes3 containing 8 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Eight filled <rect> with appropriate parameters as a string."
        }
      },
      "decode5BytesTo8Pixels(uint256,bytes5,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 5 * 8 = 40 bits = 8 * 5 = 5 bytes as a minimal bytes array to decode.",
        "params": {
          "_bytes": "The bytes5 containing 8 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Eight filled <rect> with appropriate parameters as a string."
        }
      },
      "decode7BytesTo8Pixels(uint256,bytes7,string[],uint256)": {
        "details": "This function can be used as a base decoding function when using 5 bits per pixel. In this case, one has       indeed 7 * 8 = 56 bits = 8 * 7 = 7 bytes as a minimal bytes array to decode.",
        "params": {
          "_bytes": "The bytes7 containing 8 palette indexes.",
          "imageWidth": "Since the image array is flatten, we use the imageWidth to retrieve the x and y coordinates of the rect.",
          "palette": "The array of decoded colors as hex strings.",
          "startIndex": "The index of the current pixel in the image flatten array."
        },
        "returns": {
          "_0": "Eight filled <rect> with appropriate parameters as a string."
        }
      },
      "getFill(address,uint256)": {
        "details": "Returns one single color reading directly from the storage.",
        "params": {
          "index": "The index of the color to retrieve",
          "pointer": "The pointer to the palette bytes array where each color is R, G, B at storage i, i+1, i+2."
        },
        "returns": {
          "_0": "The hexstring representation of the color, e.g. \"a3120f\"."
        }
      },
      "getFill(bytes,uint256)": {
        "details": "Returns one single color from a pre-loaded whole palette as a bytes array.",
        "params": {
          "index": "The index of the color to retrieve",
          "palette": "A bytes array encoding several RGB colors. Length should be a multiple of 3."
        },
        "returns": {
          "_0": "The hexstring representation of the color, e.g. \"a3120f\"."
        }
      },
      "getImageBytes(address,uint256,uint256,uint256)": {
        "details": "All images have a constant number of pixels and consequently a constant number of bytes.       The function reads the corresponding number of bytes at the given _pointer_ address (written with SSTORE2.write).       It is more efficient to concat all the bytes of all the images in one single bytes (<24k) to save on gas       This function eventually helps retrieve one image given its index from the bytes array.",
        "params": {
          "bitsPaletteSize": "The number of bits used to index the palette, e.g. 3 bits for 2^3 = 8 colors, 8 bits for 2^8 = 256 colors.",
          "index": "The index of the image to retrieve.",
          "pixelsCount": "The number of pixels of the image, e.g. 32x32 = 1024 pixels. This function hence reads pixelsCount * bitsPaletteSize / 8 bytes.",
          "pointer": "The pointer returned by the SSTORE2.write function (or storeBytes for instance)."
        },
        "returns": {
          "_0": "The bytes of the image."
        }
      },
      "getPalette(address)": {
        "details": "Decode the whole palette once for all and returns an array of hexstrings.",
        "params": {
          "pointer": "The pointer to the palette bytes array where each color is at storage at i, i+1, i+2."
        },
        "returns": {
          "_0": "An array of hexstring representation of the color, e.g. \"a3120f\"."
        }
      }
    },
    "title": "PaletteRenderer This library can be used to render a palette encoded image on-chain. Palette encoding means that each pixel does not store the color itself, but rather the index of the color in the palette. The returned images is an url safe encoded image uri.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}